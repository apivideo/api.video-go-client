/*
 * api.video
 *
 * api.video is an API that encodes on the go to facilitate immediate playback, enhancing viewer streaming experiences across multiple devices and platforms. You can stream live or on-demand online videos within minutes.
 *
 * API version: 1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apivideosdk

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type WatermarksApiListRequest struct {
	sortBy      *string
	sortOrder   *string
	currentPage *int32
	pageSize    *int32
}

func (r WatermarksApiListRequest) SortBy(sortBy string) WatermarksApiListRequest {
	r.sortBy = &sortBy
	return r
}
func (r WatermarksApiListRequest) SortOrder(sortOrder string) WatermarksApiListRequest {
	r.sortOrder = &sortOrder
	return r
}
func (r WatermarksApiListRequest) CurrentPage(currentPage int32) WatermarksApiListRequest {
	r.currentPage = &currentPage
	return r
}
func (r WatermarksApiListRequest) PageSize(pageSize int32) WatermarksApiListRequest {
	r.pageSize = &pageSize
	return r
}

type WatermarksServiceI interface {
	/*
	 * Delete Delete a watermark
	 * @param watermarkId The watermark ID for the watermark you want to delete.
	 * @return WatermarksApiDeleteRequest
	 */

	Delete(watermarkId string) error

	/*
	 * Delete Delete a watermark
	 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param watermarkId The watermark ID for the watermark you want to delete.
	 * @return WatermarksApiDeleteRequest
	 */

	DeleteWithContext(ctx context.Context, watermarkId string) error

	/*
	 * List List all watermarks
	 * @return WatermarksApiListRequest
	 */

	List(r WatermarksApiListRequest) (*WatermarksListResponse, error)

	/*
	 * List List all watermarks
	 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return WatermarksApiListRequest
	 */

	ListWithContext(ctx context.Context, r WatermarksApiListRequest) (*WatermarksListResponse, error)

	/*
	 * Upload Upload a watermark
	 * @return WatermarksApiUploadRequest
	 */
	Upload(fileName string, fileReader io.Reader) (*Watermark, error)
	/*
	 * Upload Upload a watermark
	 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return WatermarksApiUploadRequest
	 */
	UploadWithContext(ctx context.Context, fileName string, fileReader io.Reader) (*Watermark, error)

	/*
	 * Upload Upload a watermark
	 * @return WatermarksApiUploadRequest
	 */
	UploadFile(file *os.File) (*Watermark, error)

	/*
	 * Upload Upload a watermark
	 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return WatermarksApiUploadRequest
	 */
	UploadFileWithContext(ctx context.Context, file *os.File) (*Watermark, error)
}

// WatermarksService communicating with the Watermarks
// endpoints of the api.video API
type WatermarksService struct {
	client *Client
}

/*
 * Delete Delete a watermark
 * Delete a watermark. A watermark is a static image overlapping a video used as a "stamp" to limit leetching.

 * @param watermarkId The watermark ID for the watermark you want to delete.
 * @return WatermarksApiDeleteRequest
 */

func (s *WatermarksService) Delete(watermarkId string) error {

	return s.DeleteWithContext(context.Background(), watermarkId)

}

/*
 * Delete Delete a watermark
 * Delete a watermark. A watermark is a static image overlapping a video used as a "stamp" to limit leetching.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param watermarkId The watermark ID for the watermark you want to delete.
 * @return WatermarksApiDeleteRequest
 */

func (s *WatermarksService) DeleteWithContext(ctx context.Context, watermarkId string) error {
	var localVarPostBody interface{}

	localVarPath := "/watermarks/{watermarkId}"
	localVarPath = strings.Replace(localVarPath, "{"+"watermarkId"+"}", url.PathEscape(parameterToString(watermarkId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}

	req, err := s.client.prepareRequest(ctx, http.MethodDelete, localVarPath, localVarPostBody, localVarHeaderParams, localVarQueryParams)
	if err != nil {
		return err
	}

	_, err = s.client.do(req, nil)

	if err != nil {
		return err
	}

	return nil

}

/*
 * List List all watermarks
 * List all watermarks. A watermark is a static image overlapping a video used as a "stamp" to limit leetching.

 * @return WatermarksApiListRequest
 */

func (s *WatermarksService) List(r WatermarksApiListRequest) (*WatermarksListResponse, error) {

	return s.ListWithContext(context.Background(), r)

}

/*
 * List List all watermarks
 * List all watermarks. A watermark is a static image overlapping a video used as a "stamp" to limit leetching.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return WatermarksApiListRequest
 */

func (s *WatermarksService) ListWithContext(ctx context.Context, r WatermarksApiListRequest) (*WatermarksListResponse, error) {
	var localVarPostBody interface{}

	localVarPath := "/watermarks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.sortOrder != nil {
		localVarQueryParams.Add("sortOrder", parameterToString(*r.sortOrder, ""))
	}
	if r.currentPage != nil {
		localVarQueryParams.Add("currentPage", parameterToString(*r.currentPage, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}

	req, err := s.client.prepareRequest(ctx, http.MethodGet, localVarPath, localVarPostBody, localVarHeaderParams, localVarQueryParams)
	if err != nil {
		return nil, err
	}

	res := new(WatermarksListResponse)
	_, err = s.client.do(req, res)

	if err != nil {
		return nil, err
	}

	return res, nil

}

/*
 * Upload Upload a watermark
 * Create a new watermark by uploading a .jpg or a .png image. A watermark is a static image overlapping a video used as a "stamp" to limit leetching.

 * @return WatermarksApiUploadRequest
 */

func (s *WatermarksService) UploadFile(file *os.File) (*Watermark, error) {
	return s.UploadFileWithContext(context.Background(), file)
}

/*
 * Upload Upload a watermark
 * Create a new watermark by uploading a .jpg or a .png image. A watermark is a static image overlapping a video used as a "stamp" to limit leetching.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return WatermarksApiUploadRequest
 */

func (s *WatermarksService) UploadFileWithContext(ctx context.Context, file *os.File) (*Watermark, error) {
	return s.UploadWithContext(ctx, file.Name(), io.Reader(file))
}

/*
 * Upload Upload a watermark
 * Create a new watermark by uploading a .jpg or a .png image. A watermark is a static image overlapping a video used as a "stamp" to limit leetching.

 * @return WatermarksApiUploadRequest
 */
func (s *WatermarksService) Upload(fileName string, fileReader io.Reader) (*Watermark, error) {
	return s.UploadWithContext(context.Background(), fileName, fileReader)
}

/*
 * Upload Upload a watermark
 * Create a new watermark by uploading a .jpg or a .png image. A watermark is a static image overlapping a video used as a "stamp" to limit leetching.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return WatermarksApiUploadRequest
 */
func (s *WatermarksService) UploadWithContext(ctx context.Context, fileName string, fileReader io.Reader) (*Watermark, error) {
	localVarPath := "/watermarks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := make(map[string]string)

	req, err := s.client.prepareUploadRequest(ctx, localVarPath, fileName, fileReader, localVarHeaderParams, localVarQueryParams, localVarFormParams)

	if err != nil {
		return nil, err
	}

	res := new(Watermark)
	_, err = s.client.do(req, res)

	if err != nil {
		return nil, err
	}

	return res, nil

}
